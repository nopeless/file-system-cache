{"version":3,"sources":["../src/cache.js"],"names":["f","formatPath","R","pipe","ensureString","toAbsolutePath","toGetValue","data","type","value","Date","getValueP","path","defaultValue","Promise","resolve","reject","fs","readJson","err","result","code","toJson","JSON","stringify","FileSystemCache","basePath","ns","extension","hash","isString","isFileSync","Error","key","isNothing","name","replace","existsP","basePathExists","ensureDir","existsSync","readJsonSync","ensureBasePath","then","outputFile","catch","outputFileSync","removeFileP","filePathsP","paths","remove","index","items","is","Array","isValid","item","Object","isNil","forEach","response","length","setValue","set","files","getValue"],"mappings":"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","file":"cache.js","sourcesContent":["import R from 'ramda';\nimport Promise from 'bluebird';\nimport fs from 'fs-extra';\nimport * as f from './funcs';\n\nconst formatPath = R.pipe(f.ensureString('./.cache'), f.toAbsolutePath);\n\nconst toGetValue = (data) => {\n  const { type } = data;\n  let { value } = data;\n  if (type === 'Date') { value = new Date(value); }\n  return value;\n};\n\nconst getValueP = (path, defaultValue) => new Promise((resolve, reject) => {\n  fs.readJson(path, (err, result) => {\n    if (err) {\n      if (err.code === 'ENOENT') {\n        resolve(defaultValue);\n      } else {\n        reject(err);\n      }\n    } else {\n      const value = toGetValue(result);\n      resolve(value);\n    }\n  });\n});\n\nconst toJson = (value) => JSON.stringify({ value, type: R.type(value) });\n\n\n\n/**\n * A cache that read/writes to a specific part of the file-system.\n */\nexport default class FileSystemCache {\n  /**\n   * Constructor.\n   * @param options\n   *            - basePath:   The folder path to read/write to.\n   *                          Default: './build'\n   *            - ns:         A single value, or array, that represents a\n   *                          a unique namespace within which values for this\n   *                          store are cached.\n   *            - extension:  An optional file-extension for paths.\n   */\n  constructor({ basePath, ns, extension } = {}) {\n    this.basePath = formatPath(basePath);\n    this.ns = f.hash(ns);\n    if (f.isString(extension)) { this.extension = extension; }\n    if (f.isFileSync(this.basePath)) {\n      throw new Error(`The basePath '${this.basePath}' is a file. It should be a folder.`);\n    }\n  }\n\n  /**\n   * Generates the path to the cached files.\n   * @param {string} key: The key of the cache item.\n   * @return {string}.\n   */\n  path(key) {\n    if (f.isNothing(key)) { throw new Error('Path requires a cache key.'); }\n    let name = f.hash(key);\n    if (this.ns) { name = `${this.ns}-${name}`; }\n    if (this.extension) {\n      name = `${name}.${this.extension.replace(/^\\./, '')}`;\n    }\n    return `${this.basePath}/${name}`;\n  }\n\n\n  /**\n   * Determines whether the file exists.\n   * @param {string} key: The key of the cache item.\n   * @return {Promise}\n   */\n  fileExists(key) { return f.existsP(this.path(key)); }\n\n\n  /**\n   * Ensure that the base path exists.\n   * @return {Promise}\n   */\n  ensureBasePath() {\n    return new Promise((resolve, reject) => {\n      if (this.basePathExists) {\n        resolve();\n      } else {\n        fs.ensureDir(this.basePath, (err) => {\n          if (err) {\n            reject(err);\n          } else {\n            this.basePathExists = true;\n            resolve();\n          }\n        });\n      }\n    });\n  }\n\n\n  /**\n   * Gets the contents of the file with the given key.\n   * @param {string} key: The key of the cache item.\n   * @param defaultValue: Optional. A default value to return if the value does not exist in cache.\n   * @return {Promise} - File contents, or\n   *                     undefined if the file does not exist.\n   */\n  get(key, defaultValue) { return getValueP(this.path(key), defaultValue); }\n\n\n  /**\n   * Gets the contents of the file with the given key.\n   * @param {string} key: The key of the cache item.\n   * @param defaultValue: Optional. A default value to return if the value does not exist in cache.\n   * @return the cached value, or undefined.\n   */\n  getSync(key, defaultValue) {\n    const path = this.path(key);\n    return fs.existsSync(path)\n      ? toGetValue(fs.readJsonSync(path))\n      : defaultValue;\n  }\n\n\n  /**\n   * Writes the given value to the file-system.\n   * @param {string} key: The key of the cache item.\n   * @param value: The value to write (Primitive or Object).\n   * @return {Promise}\n   */\n  set(key, value) {\n    const path = this.path(key);\n    return new Promise((resolve, reject) => {\n      this.ensureBasePath()\n        .then(() => {\n          fs.outputFile(path, toJson(value), (err) => {\n            if (err) { reject(err); } else { resolve({ path }); }\n          });\n        })\n        .catch((err) => reject(err));\n    });\n  }\n\n\n  /**\n   * Writes the given value to the file-system and memory cache.\n   * @param {string} key: The key of the cache item.\n   * @param value: The value to write (Primitive or Object).\n   * @return the cache.\n   */\n  setSync(key, value) {\n    fs.outputFileSync(this.path(key), toJson(value));\n    return this;\n  }\n\n\n  /**\n   * Removes the item from the file-system.\n   * @param {string} key: The key of the cache item.\n   * @return {Promise}\n   */\n  remove(key) { return f.removeFileP(this.path(key)); }\n\n\n  /**\n   * Removes all items from the cache.\n   * @return {Promise}\n   */\n  clear() {\n    return new Promise((resolve, reject) => {\n      f.filePathsP(this.basePath, this.ns)\n        .then((paths) => {\n          const remove = (index) => {\n            const path = paths[index];\n            if (path) {\n              f.removeFileP(path)\n                .then(() => remove(index + 1)) // <== RECURSION.\n                .catch((err) => reject(err));\n            } else {\n              resolve(); // All files have been removed.\n            }\n          };\n          remove(0);\n          return null;\n        })\n        .catch((err) => reject(err));\n    });\n  }\n\n\n  /**\n   * Saves several items to the cache in one operation.\n   * @param {array} items: An array of objects of the form { key, value }.\n   * @return {Promise}\n   */\n  save(items) {\n    // Setup initial conditions.\n    if (!R.is(Array, items)) { items = [items]; }\n    const isValid = (item) => {\n      if (!R.is(Object, item)) { return false; }\n      return item.key && item.value;\n    };\n    items = R.pipe(\n      R.reject(R.isNil),\n      R.forEach((item) => {\n        if (!isValid(item)) {\n          throw new Error('Save items not valid, must be an array of {key, value} objects.');\n        }\n      }),\n    )(items);\n\n    return new Promise((resolve, reject) => {\n      // Don't continue if no items were passed.\n      const response = { paths: [] };\n      if (items.length === 0) {\n        resolve(response);\n        return;\n      }\n\n      // Recursively set each item to the file-system.\n      const setValue = (index) => {\n        const item = items[index];\n        if (item) {\n          this.set(item.key, item.value)\n            .then((result) => {\n              response.paths[index] = result.path;\n              setValue(index + 1); // <== RECURSION.\n              return null;\n            })\n            .catch((err) => reject(err));\n        } else {\n          // No more items - done.\n          resolve(response);\n        }\n      };\n      setValue(0);\n    });\n  }\n\n\n  /**\n   * Loads all files within the cache's namespace.\n   */\n  load() {\n    return new Promise((resolve, reject) => {\n      f.filePathsP(this.basePath, this.ns)\n        .then((paths) => {\n          // Bail out if there are no paths in the folder.\n          const response = { files: [] };\n          if (paths.length === 0) {\n            resolve(response);\n            return;\n          }\n\n          // Get each value.\n          const getValue = (index) => {\n            const path = paths[index];\n            if (path) {\n              getValueP(path)\n                .then((result) => {\n                  response.files[index] = { path, value: result };\n                  getValue(index + 1); // <== RECURSION.\n                  return null;\n                })\n                .catch((err) => reject(err));\n            } else {\n              // All paths have been loaded.\n              resolve(response);\n            }\n          };\n          getValue(0);\n        })\n        .catch((err) => reject(err));\n    });\n  }\n}\n"]}